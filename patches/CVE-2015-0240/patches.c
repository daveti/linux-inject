#include <systemd/sd-journal.h>

/*
 *  Unix SMB/CIFS implementation.
 *  RPC Pipe client / server routines
 *  Copyright (C) Andrew Tridgell              1992-1997,
 *  Copyright (C) Luke Kenneth Casson Leighton 1996-1997,
 *  Copyright (C) Paul Ashton                       1997.
 *  Copyright (C) Jeremy Allison               1998-2001.
 *  Copyright (C) Andrew Bartlett                   2001.
 *  Copyright (C) Guenther Deschner		    2008-2009.
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, see <http://www.gnu.org/licenses/>.
 */

/* This is the implementation of the netlogon pipe. */

#include "includes.h"
#include "system/passwd.h" /* uid_wrapper */
#include "ntdomain.h"
#include "../libcli/auth/schannel.h"
#include "../librpc/gen_ndr/srv_netlogon.h"
#include "../librpc/gen_ndr/ndr_samr_c.h"
#include "../librpc/gen_ndr/ndr_lsa_c.h"
#include "rpc_client/cli_lsarpc.h"
#include "rpc_client/init_lsa.h"
#include "rpc_server/rpc_ncacn_np.h"
#include "../libcli/security/security.h"
#include "../libcli/security/dom_sid.h"
#include "librpc/gen_ndr/ndr_drsblobs.h"
#include "lib/crypto/arcfour.h"
#include "lib/crypto/md4.h"
#include "nsswitch/libwbclient/wbclient.h"
#include "../libcli/registry/util_reg.h"
#include "passdb.h"
#include "auth.h"
#include "messages.h"
#include "../lib/tsocket/tsocket.h"
#include "lib/param/param.h"

/****/

/*************************************************************************
 * If schannel is required for this call test that it actually is available.
 *************************************************************************/

static NTSTATUS samr_find_machine_account(TALLOC_CTX *mem_ctx,
					  struct dcerpc_binding_handle *b,
					  const char *account_name,
					  uint32_t access_mask,
					  struct dom_sid2 **domain_sid_p,
					  uint32_t *user_rid_p,
					  struct policy_handle *user_handle)
{
	NTSTATUS status;
	NTSTATUS result = NT_STATUS_OK;
	struct policy_handle connect_handle;
	struct policy_handle domain_handle = { 0, };
	struct lsa_String domain_name;
	struct dom_sid2 *domain_sid;
	struct lsa_String names;
	struct samr_Ids rids;
	struct samr_Ids types;
	uint32_t rid;

	status = dcerpc_samr_Connect2(b, mem_ctx,
				      lp_netbios_name(),
				      SAMR_ACCESS_CONNECT_TO_SERVER |
				      SAMR_ACCESS_ENUM_DOMAINS |
				      SAMR_ACCESS_LOOKUP_DOMAIN,
				      &connect_handle,
				      &result);
	if (!NT_STATUS_IS_OK(status)) {
		goto out;
	}
	if (!NT_STATUS_IS_OK(result)) {
		status = result;
		goto out;
	}

	init_lsa_String(&domain_name, get_global_sam_name());

	status = dcerpc_samr_LookupDomain(b, mem_ctx,
					  &connect_handle,
					  &domain_name,
					  &domain_sid,
					  &result);
	if (!NT_STATUS_IS_OK(status)) {
		goto out;
	}
	if (!NT_STATUS_IS_OK(result)) {
		status = result;
		goto out;
	}

	status = dcerpc_samr_OpenDomain(b, mem_ctx,
					&connect_handle,
					SAMR_DOMAIN_ACCESS_OPEN_ACCOUNT,
					domain_sid,
					&domain_handle,
					&result);
	if (!NT_STATUS_IS_OK(status)) {
		goto out;
	}
	if (!NT_STATUS_IS_OK(result)) {
		status = result;
		goto out;
	}

	init_lsa_String(&names, account_name);

	status = dcerpc_samr_LookupNames(b, mem_ctx,
					 &domain_handle,
					 1,
					 &names,
					 &rids,
					 &types,
					 &result);
	if (!NT_STATUS_IS_OK(status)) {
		goto out;
	}
	if (!NT_STATUS_IS_OK(result)) {
		status = result;
		goto out;
	}

	if (rids.count != 1) {
		status = NT_STATUS_NO_SUCH_USER;
		goto out;
	}
	if (types.count != 1) {
		status = NT_STATUS_INVALID_PARAMETER;
		goto out;
	}
	if (types.ids[0] != SID_NAME_USER) {
		status = NT_STATUS_NO_SUCH_USER;
		goto out;
	}

	rid = rids.ids[0];

	status = dcerpc_samr_OpenUser(b, mem_ctx,
				      &domain_handle,
				      access_mask,
				      rid,
				      user_handle,
				      &result);
	if (!NT_STATUS_IS_OK(status)) {
		goto out;
	}
	if (!NT_STATUS_IS_OK(result)) {
		status = result;
		goto out;
	}

	if (user_rid_p) {
		*user_rid_p = rid;
	}

	if (domain_sid_p) {
		*domain_sid_p = domain_sid;
	}

 out:
	if (is_valid_policy_hnd(&domain_handle)) {
		dcerpc_samr_Close(b, mem_ctx, &domain_handle, &result);
	}
	if (is_valid_policy_hnd(&connect_handle)) {
		dcerpc_samr_Close(b, mem_ctx, &connect_handle, &result);
	}

	return status;
}

static NTSTATUS schannel_check_required(struct pipe_auth_data *auth_info,
					const char *computer_name,
					bool integrity, bool privacy)
{
	if (auth_info && auth_info->auth_type == DCERPC_AUTH_TYPE_SCHANNEL) {
		if (!privacy && !integrity) {
			return NT_STATUS_OK;
		}

		if ((!privacy && integrity) &&
		    auth_info->auth_level == DCERPC_AUTH_LEVEL_INTEGRITY) {
			return NT_STATUS_OK;
		}

		if ((privacy || integrity) &&
		    auth_info->auth_level == DCERPC_AUTH_LEVEL_PRIVACY) {
			return NT_STATUS_OK;
		}
	}

	/* test didn't pass */
	DEBUG(0, ("schannel_check_required: [%s] is not using schannel\n",
		  computer_name));

	return NT_STATUS_ACCESS_DENIED;
}

static NTSTATUS netr_set_machine_account_password(TALLOC_CTX *mem_ctx,
						  struct auth_session_info *session_info,
						  struct messaging_context *msg_ctx,
						  const char *account_name,
						  struct samr_Password *nt_hash)
{
	NTSTATUS status;
	NTSTATUS result = NT_STATUS_OK;
	struct dcerpc_binding_handle *h = NULL;
	struct tsocket_address *local;
	struct policy_handle user_handle;
	uint32_t acct_ctrl;
	union samr_UserInfo *info;
	struct samr_UserInfo18 info18;
	DATA_BLOB in,out;
	int rc;
	DATA_BLOB session_key;

	ZERO_STRUCT(user_handle);

	status = session_extract_session_key(session_info,
					     &session_key,
					     KEY_USE_16BYTES);
	if (!NT_STATUS_IS_OK(status)) {
		goto out;
	}

	rc = tsocket_address_inet_from_strings(mem_ctx,
					       "ip",
					       "127.0.0.1",
					       0,
					       &local);
	if (rc < 0) {
		status = NT_STATUS_NO_MEMORY;
		goto out;
	}

	status = rpcint_binding_handle(mem_ctx,
				       &ndr_table_samr,
				       local,
				       session_info,
				       msg_ctx,
				       &h);
	if (!NT_STATUS_IS_OK(status)) {
		goto out;
	}

	become_root();
	status = samr_find_machine_account(mem_ctx,
					   h,
					   account_name,
					   SEC_FLAG_MAXIMUM_ALLOWED,
					   NULL,
					   NULL,
					   &user_handle);
	unbecome_root();
	if (!NT_STATUS_IS_OK(status)) {
		goto out;
	}

	status = dcerpc_samr_QueryUserInfo2(h,
					    mem_ctx,
					    &user_handle,
					    UserControlInformation,
					    &info,
					    &result);
	if (!NT_STATUS_IS_OK(status)) {
		goto out;
	}
	if (!NT_STATUS_IS_OK(result)) {
		status = result;
		goto out;
	}

	acct_ctrl = info->info16.acct_flags;

	if (!(acct_ctrl & ACB_WSTRUST ||
	      acct_ctrl & ACB_SVRTRUST ||
	      acct_ctrl & ACB_DOMTRUST)) {
		status = NT_STATUS_NO_SUCH_USER;
		goto out;
	}

	if (acct_ctrl & ACB_DISABLED) {
		status = NT_STATUS_ACCOUNT_DISABLED;
		goto out;
	}

	ZERO_STRUCT(info18);

	in = data_blob_const(nt_hash->hash, 16);
	out = data_blob_talloc_zero(mem_ctx, 16);
	sess_crypt_blob(&out, &in, &session_key, true);
	memcpy(info18.nt_pwd.hash, out.data, out.length);

	info18.nt_pwd_active = true;

	info->info18 = info18;

	become_root();
	status = dcerpc_samr_SetUserInfo2(h,
					  mem_ctx,
					  &user_handle,
					  UserInternal1Information,
					  info,
					  &result);
	unbecome_root();
	if (!NT_STATUS_IS_OK(status)) {
		goto out;
	}
	if (!NT_STATUS_IS_OK(result)) {
		status = result;
		goto out;
	}

 out:
	if (h && is_valid_policy_hnd(&user_handle)) {
		dcerpc_samr_Close(h, mem_ctx, &user_handle, &result);
	}

	return status;
}

/****/

NTSTATUS patched_netr_creds_server_step_check(struct pipes_struct *p,
					     TALLOC_CTX *mem_ctx,
					     const char *computer_name,
					     struct netr_Authenticator *received_authenticator,
					     struct netr_Authenticator *return_authenticator,
					     struct netlogon_creds_CredentialState **creds_out)
{
	NTSTATUS status;
	bool schannel_global_required = (lp_server_schannel() == true) ? true:false;
	struct loadparm_context *lp_ctx;

sd_journal_print(LOG_INFO, "%s: %d\n", __func__, __LINE__);

	if (schannel_global_required) {
		status = schannel_check_required(&p->auth,
						 computer_name,
						 false, false);
		if (!NT_STATUS_IS_OK(status)) {
			return status;
		}
	}

	lp_ctx = loadparm_init_s3(mem_ctx, loadparm_s3_helpers());
	if (lp_ctx == NULL) {
		DEBUG(0, ("loadparm_init_s3 failed\n"));
		return NT_STATUS_INTERNAL_ERROR;
	}

	status = schannel_check_creds_state(mem_ctx, lp_ctx,
					    computer_name, received_authenticator,
					    return_authenticator, creds_out);
	talloc_unlink(mem_ctx, lp_ctx);
	return status;
}

NTSTATUS patched__netr_ServerPasswordSet(struct pipes_struct *p,
				 struct netr_ServerPasswordSet *r)
{
	NTSTATUS status = NT_STATUS_OK;
	int i;
	struct netlogon_creds_CredentialState *creds;

sd_journal_print(LOG_INFO, "%s: %d\n", __func__, __LINE__);

	DEBUG(5,("_netr_ServerPasswordSet: %d\n", __LINE__));

	become_root();
	status = patched_netr_creds_server_step_check(p, p->mem_ctx,
					      r->in.computer_name,
					      r->in.credential,
					      r->out.return_authenticator,
					      &creds);
	unbecome_root();

	if (!NT_STATUS_IS_OK(status)) {
		DEBUG(2,("_netr_ServerPasswordSet: netlogon_creds_server_step failed. Rejecting auth "
			"request from client %s machine account %s\n",
			r->in.computer_name, creds->computer_name));
		TALLOC_FREE(creds);
		return status;
	}

	DEBUG(3,("_netr_ServerPasswordSet: Server Password Set by remote machine:[%s] on account [%s]\n",
			r->in.computer_name, creds->computer_name));

	netlogon_creds_des_decrypt(creds, r->in.new_password);

	DEBUG(100,("_netr_ServerPasswordSet: new given value was :\n"));
	for(i = 0; i < sizeof(r->in.new_password->hash); i++)
		DEBUG(100,("%02X ", r->in.new_password->hash[i]));
	DEBUG(100,("\n"));

	status = netr_set_machine_account_password(p->mem_ctx,
						   p->session_info,
						   p->msg_ctx,
						   creds->account_name,
						   r->in.new_password);
	return status;
}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
